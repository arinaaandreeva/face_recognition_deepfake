# Модель распознавания лиц, способную противостоять DeepFake-атакам

Модель должна уметь определять один ли человек на реальных фото, а также различать является ли фото реальным или сгенерированным ИИ.
Цель:
Обучение энкодера изображений, работающего для лиц. Он должен обладать следующими характеристиками: 
1. Cosine similarity **близок к единице**, когда на обоих изображениях реальные **фотографии одного и того же человека**. Является позитивным запросом.
2. Cosine similarity **не должен быть близок к единице**, когда на обоих изображениях реальные **фотографии разных людей**, либо одно из изображений содержит **сгенерированное лицо**. Является негативным запросом.


### Описание данных
     На основании соревнования https://codenrock.com/contests/kryptonite-ml-challenge/
     Данные для обучения: https://www.kaggle.com/datasets/peach785/deepfake
     Данные для теста: https://www.kaggle.com/datasets/peach785/test-deepfake
  Данные - реальные и синтетически сгенерированные изображения лиц расположены в папке data.
  ** Структура файлов **
  
        data
        ├── test_public  # тестовые данные
        │   ├── 00000000    # pair_id - ID сравниваемой пары сообщений
        │   │   ├── 0.jpg
        │   │   └── 1.jpg
        │   ├── 00000001
        │   │   ├── 0.jpg
        │   │   └── 1.jpg
        ...
        └── train   # данные для обучения модели
        │   ├── meta.json 
        │   ├── images 
        │   │   ├── 00000000    # label - ID человека
        │   │   │   ├── 0.jpg
        │   │   │   ├── 1.jpg
        │   │   │   ├── 2.jpg
        │   │   │  ...
        │   │   │   └── k_0.jpg
        │   │   ├── 00000001
        │   │   │   ├── 0.jpg
        │   │   │   ├── 1.jpg
        │   │   │   ├── 2.jpg
        │   │   │  ...
        │   │   │   └── k_1.jpg
        ...


meta.json имеет структуру face_index/i.jpg : is_deepfake. Ключ содержит информацию о индексе человека и номере изображения, значение равно 0 для реальных данных и равно 1 для синтетических данных.
     
     ├── deepfake/face_aligner_model 
     │   ├── aligners
     │   ├── config.json
     │   ├── pretrained_model <---------------- предобученная модель для выравнивания
     │   │   └── model.yaml
     │   └── aligner_wrapper.py <---------------------- Загрузка и определение модели
     ├── deepfake/models <----------------------------- Папка с использованными моделями
     │   ├──...
     │   ├──... 
     
   
### Используемые модели

Сначала лица выравниваются, т.е. выявляется лицо с помощью https://huggingface.co/minchul/cvlface_DFA_resnet50

| Модель                   | EER на тесте |
|--------------------------|--------------|
| ResNet18                 | 0.34         |
| Siamese Neural Network   | 0.306        |
| AdaFace                  | 0.25         |
| CNN                      |              |

Ошибка у данных моделей была значительно выше 
![alt text](https://github.com/arinaaandreeva/face_recognition_deepfake/blob/main/old_ipynb/img/EER_resnet.jpg)
      
- AdaFace (EER на тесте = 0.25) https://arxiv.org/pdf/2204.00964

**AdaFace** показывает высокое качество как на бенчмарках ![alt text](https://github.com/arinaaandreeva/face_recognition_deepfake/blob/main/old_ipynb/img/adaFace.PNG)

Так и на данном датасете AdaFace ошибка меньше, чем у других моделей
![alt text](https://github.com/arinaaandreeva/face_recognition_deepfake/blob/main/old_ipynb/img/EER_adaFace.PNG)

  
#### Метрика качества EER: 
          import numpy as np
          from sklearn.metrics import roc_curve
          
          def compute_eer(y_true, y_score):
              fpr, tpr, threshold = roc_curve(y_true, y_score)
          
              # заменяем np.inf на max + eps
              eps = 1e-3
              threshold[0] = max(threshold[1:]) + eps
          
              fnr = 1 - tpr
              eer_index = np.nanargmin(np.absolute((fnr - fpr)))
              eer = fnr[eer_index]
              return eer


### Loss Function 
Adaptive margin был выбран, так как необходимо, чтобы функция потерь сохраняла баланс между задачей поиска дипфейков и сравнения фото. Было решено, что лучше всего баланс поддерживает adaptive margin.
Adaptive Margin Loss динамически изменяет величину отступа (margin) в зависимости от степени сходства между примерами
Основные особенности:

+ Величина margin автоматически регулируется на основе косинусного сходства. При низком сходстве margin увеличивается
+ Метод менее чувствителен к ошибочным меткам и аномальным данным.

- Подбор оптимальных параметров для адаптации margin может быть затруднен
- Для расчета адаптивного отступа требуется больше вычислительных ресурсов по сравнению с фиксированным.

### Future work
В задаче наблюдается дисбаланс классов (фэйковых фото значительно меньше), что ухудшает работу моделей
Часто распределение результатов на тесте выглядело так
![alt text](https://github.com/arinaaandreeva/face_recognition_deepfake/blob/main/old_ipynb/img/hist_test.jpg)
Можно расширить датасет, сгенерировав дипфейки самим с помощью Roop, Ghost, Arc2Face, InstantID и тп

### Применение технологии:

1. Безопасность и контроль доступа
   
 - Разблокировка устройств: Например, разблокировка смартфонов, ноутбуков и других гаджетов с помощью распознавания лица.
 - Контроль доступа в помещения: Использование в системах контроля доступа в офисы, банки, аэропорты и другие охраняемые объекты.
 - Пограничный контроль: Идентификация личности на границах и в аэропортах.

2. Финансовые услуги
 
 - Банковские операции: Верификация клиентов при онлайн-платежах, открытии счетов или получении кредитов.
 - Биометрическая аутентификация: Использование в мобильных приложениях банков для подтверждения транзакций.




![alt text](https://github.com/arinaaandreeva/face_recognition_deepfake/blob/main/old_ipynb/img/mem.png)

















